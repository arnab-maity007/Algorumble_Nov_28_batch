// Start of BODY
/**
 * TestStruct members::
 *  testcase_id                   [size_t] ID of the test-case
 *  testcase_input_path           [string] File path to test-case input
 *  testcase_output_path          [string] File path to test-case output generated by the problem solver
 *  testcase_expected_output_path [string] File path to test-case expected output to be matched with
 *  testcase_error_path           [string] File path to test-case STDERR
 *  metadata_file_paths           [vector<string>] File paths to Question metadata (Extra files usually used for defining traning sets)
 *  submission_code_path          [string] File path to submission source code
 *  submission_language           [string] Language token of submission
 *  testcase_result               [bool] Set to true if test-case output matches test-case expected output. Matching is done line by line
 *  testcase_signal               [size_t] Exit code of the test-case process
 *  testcase_time                 [float] Time taken by the test-case process in seconds
 *  testcase_memory               [size_t] Peak memory of the test-case process determined in bytes
 *  data                          [string] <Future use>
 *
 *
 *  ResultStruct::
 *    result      [bool]  Assign test-case result. true determines success. false determines failure
 *    score       [float] Assign test-case score. Normalized between 0 to 1
 *    message     [string] Assign test-case message. This message is visible to the problem solver
**/


void run_custom_checker(const TestStruct t_obj,
                        ResultStruct &r_obj) {
 // 1. Open the Input File (Provided by HackerRank)
    ifstream input_file(t_obj.testcase_input_path);
    
    // 2. Open the User's Output File
    ifstream user_output(t_obj.testcase_output_path);

    // Safety check: if files didn't open
    if (!input_file.is_open() || !user_output.is_open()) {
        r_obj.result = false;
        r_obj.score = 0.0f;
        r_obj.message = "Error: Could not open input or output file.";
        return;
    }

    int T;
    // Read number of test cases from input
    if (!(input_file >> T)) {
        r_obj.result = false;
        r_obj.score = 0.0f;
        r_obj.message = "Error: Input file format is invalid.";
        return;
    }

    // Helper lambda for GCD (Greatest Common Divisor)
    auto gcd_func = [](long long a, long long b) {
        while (b) {
            long long temp = b;
            b = a % b;
            a = temp;
        }
        return a;
    };

    // Loop through all test cases
    for (int i = 0; i < T; ++i) {
        long long c;
        input_file >> c; // Read 'c' from input

        long long a, b;
        // Read user's 'a' and 'b'
        if (!(user_output >> a >> b)) {
            r_obj.result = false;
            r_obj.score = 0.0f;
            r_obj.message = "Wrong Answer: Output missing or incorrect format.";
            return;
        }

        // 3. Check Constraints: 1 <= a, b <= 10^17
        if (a < 1 || a > 100000000000000000LL || b < 1 || b > 100000000000000000LL) {
            r_obj.result = false;
            r_obj.score = 0.0f;
            r_obj.message = "Wrong Answer: Values must be between 1 and 10^17.";
            return;
        }

        // 4. Check the Equation: (a ^ c) + (b ^ c) == lcm(a, c) + lcm(b, c)
        
        // Calculate LHS (Left Hand Side)
        // Use __int128_t to prevent overflow during calculation
        __int128_t lhs = (__int128_t)(a ^ c) + (__int128_t)(b ^ c);

        // Calculate RHS (Right Hand Side) using LCM formula: (a*b)/gcd(a,b)
        // We compute lcm(a, c) and lcm(b, c) separately
        __int128_t lcm_a_c = ((__int128_t)a * c) / gcd_func(a, c);
        __int128_t lcm_b_c = ((__int128_t)b * c) / gcd_func(b, c);
        
        __int128_t rhs = lcm_a_c + lcm_b_c;

        if (lhs != rhs) {
            r_obj.result = false;
            r_obj.score = 0.0f;
            r_obj.message = "Wrong Answer: The equation is not satisfied.";
            return;
        }
    }

    // If we passed the loop, all test cases are correct!
    r_obj.result = true;
    r_obj.score = 1.0f;
    r_obj.message = "Correct Answer";
}
// End of BODY
        